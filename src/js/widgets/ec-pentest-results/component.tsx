import { useTranslation } from "@opendash/core";
import { createWidgetComponent } from "@opendash/plugin-monitoring";
import { useDataService } from "@opendash/plugin-timeseries";
import { Empty } from "antd";
import dayjs from "dayjs";
import { EChartsOption } from "echarts";
import ReactECharts from "echarts-for-react";
import * as React from "react";
import { ConfigInterface, SeriesDataType } from "./types";

export default createWidgetComponent<ConfigInterface>(
  ({ config, ...context }) => {
    const t = useTranslation();
    const DataService = useDataService();
    const { width, height } = context.useContainerSize();
    const margin = [150, 80];
    const name = context
      .useItemDimensionConfig()
      .map(([item, dimension]) => DataService.getItemName(item, dimension))
      .join(", ");

    const dimensionsForYAxis = Array.from(
      new Set(
        context
          .useItemDimensionConfig()
          .map(([item, dimension]) => item.valueTypes)
          .flat()
      )
    );

    context.setName(
      t("echarts:pentestresults.graph.name", {
        name: name,
      })
    );

    const chartConfig: EChartsOption = context.useFetchDimensionValues(
      {},
      (history) => {
        console.log(history);

        // Get all unique dates for the X-axis
        const timesForXAxis = Array.from(
          new Set(history.map((item) => item[2].map((d) => d.date)).flat())
        ).sort();

        // Process data to handle multiple points per date
        const data: SeriesDataType[] = [];
        const datePointCounters: { [date: number]: number } = {};
        const dataByDate: { [date: number]: SeriesDataType[] } = {}; // Group data by date

        history.forEach((item, itemIndex) => {
          item[2]
            .filter((d) => d.value !== undefined && d.value.length !== 0)
            .forEach((d, i) => {
              // Track how many points we have for each date
              if (!datePointCounters[d.date]) {
                datePointCounters[d.date] = 0;
                dataByDate[d.date] = []; // Initialize array for this date
              }
              const pointIndexForDate = datePointCounters[d.date];
              datePointCounters[d.date]++;

              // Find the base X position for this date
              const baseDateIndex = timesForXAxis.indexOf(d.date);

              // Create a unique X position by adding a small offset for multiple points on same date
              // This spreads multiple points horizontally around the date
              const maxPointsPerDate = 10; // Maximum expected points per date
              const spreadWidth = 0.8; // How much to spread points (0.8 = 80% of space between dates)
              const offsetX =
                pointIndexForDate > 0
                  ? (pointIndexForDate - (datePointCounters[d.date] - 1) / 2) *
                    (spreadWidth / maxPointsPerDate)
                  : 0;

              const yIndex = dimensionsForYAxis.findIndex(
                (dim) => dim.name === item[0].valueTypes[item[1]].name
              );

              // Create point data with enhanced information
              const pointData: SeriesDataType = {
                id: `pentestresult-${itemIndex}-${d.date}-${i}`,
                name: Array.isArray(d.value)
                  ? `Port: ${d.value[0] || "N/A"}${
                      d.value[7] ? `, Service: ${d.value[7]}` : ""
                    }`
                  : d.value?.toString() || "N/A",
                value: [
                  baseDateIndex + offsetX, // x coordinate with offset for multiple points
                  yIndex, // y coordinate
                ],
                rawData: Array.isArray(d.value) ? d.value : [d.value],
                date: d.date,
              };

              data.push(pointData);
              dataByDate[d.date].push(pointData); // Group by date
            });
        });

        // Create series array - one series per date for proper legend support
        const colors = [
          "#ff6b6b",
          "#4ecdc4",
          "#45b7d1",
          "#f7b731",
          "#5f27cd",
          "#00d2d3",
          "#ff9ff3",
          "#54a0ff",
        ];

        const seriesArray = timesForXAxis.map((date, dateIndex) => {
          const seriesData = dataByDate[date] || [];
          const dateLabel = dayjs(new Date(date)).format("DD.MM.YY HH:mm");

          return {
            name: dateLabel, // This will appear in the legend
            type: "scatter" as const,
            symbolSize: (value: any, params: any) => {
              // Vary symbol size based on data density at this date
              const pointsAtDate = datePointCounters[date] || 1;
              return Math.max(8, 20 - pointsAtDate * 1.5); // Smaller symbols when more points
            },
            data: seriesData,
            itemStyle: {
              color: colors[dateIndex % colors.length],
              borderColor: "#333",
              borderWidth: 1,
              opacity: 0.8,
            },
            emphasis: {
              scale: 1.5,
              itemStyle: {
                borderWidth: 2,
                opacity: 1,
              },
              label: {
                show: true,
                formatter: (params: any) => {
                  return (params.data as SeriesDataType).name;
                },
                color: "#333",
                fontSize: 10,
                position: "top",
              },
            },
          };
        });

        return {
          title: {
            text: t("echarts:pentestresult.title"),
            left: "center",
            textStyle: {
              fontSize: 18,
              fontWeight: "bold",
            },
          },
          tooltip: {
            trigger: "item",
            formatter: (params: any) => {
              const data = params.data as SeriesDataType;
              const dateIndex = Math.round(data.value[0]);
              const date = timesForXAxis[dateIndex];
              const formattedDate = dayjs(new Date(date)).format(
                "DD.MM.YY HH:mm:ss"
              );

              // Extract pentest details from rawData based on your JSON structure
              const rawData = data.rawData || [];
              const port = rawData[0] || "N/A";
              const vulnerability = rawData[1] || "N/A";
              const description = rawData[2] || "N/A";
              const cve = rawData[3] || "N/A";
              const cvssBase = rawData[4] || "N/A";
              const severity = rawData[5] || "N/A";
              const solution = rawData[6] || "N/A";
              const service = rawData[7] || "N/A";

              let tooltipContent = `<strong>Pentest Result</strong><br/>`;
              tooltipContent += `<strong>Date:</strong> ${formattedDate}<br/>`;

              if (port !== "N/A" && port !== "") {
                tooltipContent += `<strong>Port:</strong> ${port}<br/>`;
              }

              if (service !== "N/A" && service !== "") {
                tooltipContent += `<strong>Service:</strong> ${service}<br/>`;
              }

              if (vulnerability !== "N/A" && vulnerability !== "") {
                tooltipContent += `<strong>Vulnerability:</strong> ${vulnerability}<br/>`;
              }

              if (cve !== "N/A" && cve !== "") {
                tooltipContent += `<strong>CVE:</strong> ${cve}<br/>`;
              }

              if (cvssBase !== "N/A" && cvssBase !== "") {
                tooltipContent += `<strong>CVSS Base:</strong> ${cvssBase}<br/>`;
              }

              if (severity !== "N/A" && severity !== "") {
                tooltipContent += `<strong>Severity:</strong> ${severity}<br/>`;
              }

              if (description !== "N/A" && description !== "") {
                tooltipContent += `<strong>Description:</strong> ${description}<br/>`;
              }

              if (solution !== "N/A" && solution !== "") {
                tooltipContent += `<strong>Solution:</strong> ${solution}`;
              }

              return tooltipContent;
            },
            backgroundColor: "#fff",
            borderColor: "#ccc",
            borderWidth: 1,
            textStyle: {
              color: "#333",
              fontSize: 12,
            },
            padding: 12,
          },
          xAxis: {
            type: "value", // Changed to value type to support decimal positions
            min: -0.5,
            max: timesForXAxis.length - 0.5,
            axisLabel: {
              color: "#555",
              fontSize: 12,
              rotate: 45,
              formatter: (value: number) => {
                const index = Math.round(value);
                if (index >= 0 && index < timesForXAxis.length) {
                  return dayjs(new Date(timesForXAxis[index])).format(
                    "DD.MM.YY HH:mm"
                  );
                }
                return "";
              },
            },
            axisTick: {
              alignWithLabel: true,
            },
            splitLine: {
              show: true,
              lineStyle: {
                color: "#e8e8e8",
                type: "dashed",
              },
            },
            name: t("echarts:pentestresult.xaxis.name"),
            nameLocation: "middle",
            nameGap: 80,
            nameTextStyle: {
              fontSize: 16,
              fontWeight: "bold",
              color: "#333",
            },
          },
          yAxis: {
            type: "category",
            data: dimensionsForYAxis.map(
              (d) =>
                `${d.name.toString() || "n/a"}${d.unit ? ` (${d.unit})` : ""}`
            ),
            axisLabel: {
              color: "#555",
              fontSize: 12,
            },
            name: t("echarts:pentestresult.yaxis.name"),
            nameLocation: "middle",
            nameGap: 120,
            nameTextStyle: {
              fontSize: 16,
              fontWeight: "bold",
              color: "#333",
            },
          },
          grid: {
            left: margin[1],
            right: margin[1],
            top: margin[0],
            bottom: margin[0] + 40, // Extra space for legend
            containLabel: true,
          },
          legend: {
            show: true,
            bottom: 10,
            textStyle: {
              fontSize: 11,
            },
            type: "scroll", // Allow scrolling if too many items
            pageButtonItemGap: 10,
          },
          series: seriesArray,
          animation: true,
          animationDuration: 1000,
        } as EChartsOption;
      },
      (item, dimension, value, index) => {}
    ) || { series: [] };

    context.setLoading(false);

    return (
      <>
        {typeof chartConfig !== "undefined" ? (
          <ReactECharts
            option={chartConfig}
            style={{ height: height, width: width }}
          />
        ) : (
          <Empty></Empty>
        )}
      </>
    );
  }
);
