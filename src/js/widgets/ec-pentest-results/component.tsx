import { useTranslation } from "@opendash/core";
import { createWidgetComponent } from "@opendash/plugin-monitoring";
import { useDataService } from "@opendash/plugin-timeseries";
import { Empty } from "antd";
import dayjs from "dayjs";
import { EChartsOption, ScatterSeriesOption } from "echarts";
import ReactECharts from "echarts-for-react";
import * as React from "react";
import { tooltipFormatter } from "./helper";
import { ConfigInterface, SeriesDataType } from "./types";

export default createWidgetComponent<ConfigInterface>(
  ({ config, ...context }) => {
    const t = useTranslation();
    const DataService = useDataService();
    const { width, height } = context.useContainerSize();
    const margin = [150, 80];
    const colors = [
      "#ff6b6b",
      "#4ecdc4",
      "#45b7d1",
      "#f7b731",
      "#5f27cd",
      "#00d2d3",
      "#ff9ff3",
      "#54a0ff",
    ];

    const name = context
      .useItemConfig()
      .map((item) => DataService.getItemName(item))
      .join(", ");

    const valueTypes = context
      .useItemConfig()
      .map((item) => item.valueTypes.map((valueType) => valueType.type));

    const dimensionsForYAxis = context
      .useItemConfig()
      .map((item) => item.valueTypes.map((valueType) => valueType.name))[0];

    context.setName(
      t("echarts:pentestresults.graph.name", {
        name: name,
      })
    );

    const result = context.useFetchValues(
      {},
      (history) => {
        console.log(history);
        const timesForXAxis: Set<number> = new Set();

        for (const item of history) {
          for (const d of item[1]) {
            timesForXAxis.add(d.date);
          }
        }

        const timesForXAxisSorted = Array.from(timesForXAxis).sort(
          (a, b) => a - b
        );

        const series: ScatterSeriesOption[] = history.map((item, itemIndex) => {
          const itemAndXPositionMap = new Map<
            number,
            { date: number; xPosition: number }
          >();

          for (let i = 0; i < item[1].length; i++) {
            const element = item[1][i];
            //Check if itemAndXPositionMap already has an entry for d.date
            //If yes, increase currentXPosition by 1
            //If no, set currentXPosition to 0
            const currentXPosition = Array.from(
              itemAndXPositionMap.entries()
            ).find((entr) => entr[1].date === element.date);

            if (currentXPosition) {
              itemAndXPositionMap.set(i, {
                date: element.date,
                xPosition: (itemAndXPositionMap.get(i)?.xPosition || 0) + 0.2,
              });
            } else {
              itemAndXPositionMap.set(i, { date: element.date, xPosition: 0 });
            }
          }

          // Prepare all the data points for the current item to the series data points
          const data = item[1]
            .filter((d) => d.value !== undefined && d.value.length !== 0)
            .map((d, j) => {
              const mappedSeriesData: SeriesDataType[] = [];

              // Create point data with enhanced information
              for (let i = 0; i < d.value.length; i++) {
                if (d.value[i].length === 0) {
                  continue;
                }

                const xPos =
                  Array.from(timesForXAxisSorted).indexOf(d.date) +
                  itemAndXPositionMap.get(j)!.xPosition;

                mappedSeriesData.push({
                  id: `pentestresult-${itemIndex}-${d.date}-${j}`,
                  name: d.value[i],
                  value: [
                    xPos, // x coordinate with offset for multiple points
                    dimensionsForYAxis.indexOf(dimensionsForYAxis[i]), // y coordinate
                  ],
                  rawData: Array.isArray(d.value) ? d.value : [d.value],
                  date: d.date,
                });
              }

              return mappedSeriesData;
            })
            .flat()
            // This will be the final mapping to the echarts data format
            // to ensure correct typing for echarts
            // as we added extra fields in SeriesDataType
            .map((point) => ({
              tooltip: {
                formatter: (params: any) => tooltipFormatter(params, point),
              },
              id: point.id,
              name: point.name,
              value: point.value,
              label: {
                show:
                  config.showLabels !== undefined ? config.showLabels : true,
                position: "top",
                formatter: (params: any) => {
                  return (params.data as SeriesDataType).name;
                },
                color: "#333",
                fontSize: 10,
                rotate: 45,
              },
            }));

          // Now return the series configuration for this item
          return {
            name: "Pentest Result for " + item[0].name, // This will appear in the legend
            type: "scatter" as const,
            symbolSize: 15,
            data: data,
            itemStyle: {
              color: colors[itemIndex % colors.length],
              borderColor: "#333",
              borderWidth: 1,
              opacity: 0.8,
            },
            emphasis: {
              scale: 1.5,
              itemStyle: {
                borderWidth: 2,
                opacity: 1,
              },
              label: {
                show: true,
                formatter: (params: any) => {
                  return (params.data as SeriesDataType).name;
                },
                color: "#333",
                fontSize: 10,
                position: "top",
              },
            },
          } as ScatterSeriesOption;
        });

        return {
          series,
          timesForXAxis: timesForXAxisSorted,
        };
      },
      (item, dimension, value, index) => {}
    ) || { series: [], timesForXAxis: [] };

    console.log(result.timesForXAxis);

    const chartConfig = {
      title: {
        text: t("echarts:pentestresult.title"),
        left: "center",
        textStyle: {
          fontSize: 18,
          fontWeight: "bold",
        },
      },
      tooltip: {
        trigger: "item",
        backgroundColor: "#fff",
        borderColor: "#ccc",
        borderWidth: 1,
        textStyle: {
          color: "#333",
          fontSize: 12,
        },
        padding: 12,
      },
      xAxis: {
        type: "value", // Changed to value type to support decimal positions
        min: -0.5,
        max: result.timesForXAxis.length - 0.5,
        axisLabel: {
          color: "#555",
          fontSize: 12,
          rotate: 45,
          interval: 0,
          customValues: result.timesForXAxis.map((ts, index) =>
            Math.round(index)
          ),
          formatter: (value: number) => {
            const index = Math.round(value);
            if (index >= 0 && index < result.timesForXAxis.length) {
              return dayjs(new Date(result.timesForXAxis[index])).format(
                "DD.MM.YY HH:mm"
              );
            }
            return "";
          },
        },
        axisTick: {
          alignWithLabel: true,
        },
        splitLine: {
          show: true,
          lineStyle: {
            color: "#5c5c5cff",
            type: "dashed",
          },
        },
        name: t("echarts:pentestresult.xaxis.name"),
        nameLocation: "middle",
        nameGap: 80,
        nameTextStyle: {
          fontSize: 16,
          fontWeight: "bold",
          color: "#333",
        },
      },
      yAxis: {
        type: "category",
        data: dimensionsForYAxis,
        axisLabel: {
          color: "#555",
          fontSize: 12,
        },
        name: t("echarts:pentestresult.yaxis.name"),
        nameLocation: "middle",
        nameGap: 120,
        nameTextStyle: {
          fontSize: 16,
          fontWeight: "bold",
          color: "#333",
        },
      },
      grid: {
        left: margin[1],
        right: margin[1],
        top: margin[0],
        bottom: margin[0] + 40, // Extra space for legend
        containLabel: true,
      },
      legend: {
        show: true,
        bottom: 10,
        textStyle: {
          fontSize: 11,
        },
        type: "scroll", // Allow scrolling if too many items
        pageButtonItemGap: 10,
      },
      series: result.series,
      animation: true,
      animationDuration: 1000,
    } as EChartsOption;

    console.log(chartConfig);

    context.setLoading(false);

    return (
      <>
        {typeof chartConfig !== "undefined" ? (
          <ReactECharts
            option={chartConfig}
            style={{ height: height, width: width }}
          />
        ) : (
          <Empty></Empty>
        )}
      </>
    );
  }
);
